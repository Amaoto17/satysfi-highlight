@import: hl-token
@import: hl-parser
@import: hl-regex
@import: color-scheme


module SyntaxOcaml : sig

  type item
  type matcher

  % val patterns : matcher list -> matcher
  val pattern : context -> string -> matcher
  val capture : int -> (item -> item) -> matcher -> matcher
  val token : token -> item -> item
  % val include : matcher -> item -> item
  val rule : context -> matcher
  val scan : context -> string -> inline-boxes

end = struct

  type item = string * context
  type matcher = (item list) exec-ctx parser

  let pattern ctx pat =
    let p = Regex.compile pat in
    p >>= (fun matched -> (
      let elem-list = List.map (fun s -> (s, ctx)) matched in
      return elem-list
    ))

  let list-nth-map n f lst =
    let-rec iter k lst =
      match lst with
      | [] -> []
      | x :: xs ->
          if k == n then (f x) :: xs
          else x :: iter (k + 1) xs
    in
    iter 0 lst

  let capture n f t =
    t >>= (fun item-list -> (
      return (list-nth-map n f item-list)
    ))

  let token tok item =
    let (s, ctx) = item in
    let ctx = ctx |> ColorScheme.set-color-of tok in
    (s, ctx)


  let rule-let ctx =
    pattern ctx `let|and`
      |> capture 0 (token Keyword)

  let rule-integer ctx =
    pattern ctx `1+`
      |> capture 0 (token NumericConstant)

  let rule ctx =
    choice [
      rule-let ctx
    ; rule-integer ctx
    ]

  let scan ctx code =
    match parse exec-ctx-init (rule ctx) code with
    | None ->
        read-inline ctx (embed-string code)
    | Some (item-list, st) ->
        let ib = List.fold-left (fun ibacc (s, ctx) ->
          ibacc ++ read-inline ctx (embed-string s)
        ) inline-nil item-list
        in
        let ib-rest =
          let len = string-length st#src in
          let rest = string-sub st#src st#offset (len - st#offset) in
          read-inline ctx (embed-string rest)
        in
        ib ++ ib-rest

end
