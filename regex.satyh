@require: option
@import: utils
@import: vector
@import: regex-types
@import: parser

open Parser


let control-char =
  choice [
    char `n` >> return (string-unexplode [12])
  ; char `t` >> return (string-unexplode [11])
  ; char `r` >> return (string-unexplode [15])
  ]

let shorthand =
  choice [
    char `w` >> return is-word-char
  ; char `W` >> return (negate is-word-char)
  ; char `d` >> return is-digit
  ; char `D` >> return (negate is-digit)
  ; char `s` >> return is-space
  ; char `S` >> return (negate is-space)
  ; char `h` >> return is-hex-digit
  ; char `H` >> return (negate is-hex-digit)
  ]


module CharClass : sig

  val parse : (string -> bool) parser

end = struct

  type class-node =
    | Class of class-node
    | Single of string
    | Range of string * string
    | Shorthand of string -> bool
    | Union of class-node * class-node
    | Prod of class-node * class-node
    | Not of class-node

  
  let build ast =
    let-rec iter node =
      match node with
      | Single c -> string-same c
      | Range (c1, c2) ->
          let pat = regexp-of-string (`[` ^ c1 ^ `-` ^ c2 ^ `]`) in
          string-match pat
      | Class t -> iter t
      | Shorthand pred -> pred
      | Not t -> negate (iter t)
      | Prod (t1, t2) -> fun x -> iter t1 x && iter t2 x
      | Union (t1, t2) -> fun x -> iter t1 x || iter t2 x
    in
    return (iter ast)


  let class-meta-char = `[]&-\`

  let item = none-of class-meta-char

  let-rec escaped = fun st -> st |> run (
    char `\` >>
    choice [
      control-char >>= (fun c -> (
        return (Single c)
      ))
    ; shorthand >>= (fun pred -> (
        return (Shorthand pred)
      ))
    ; any >>= (fun c -> (
        return (Single c)
      ))
    ]
  )

  and range c1 =
    char `-` >>
    item >>= (fun c2 -> (
      return (Range (c1, c2))
    ))

  and primary = fun st -> st |> run (
    choice [
      char `[` >>
      class >>= (fun t -> (
        return (Class t)
      ))
    ; escaped
    ; item >>= (fun c -> (
        (range c) <|> return (Single c)
      ))
    ]
  )

  and enum = fun st -> st |> run (
    let enum-op =
      return (fun t1 t2 -> Union (t1, t2))
    in
    chainl primary enum-op
  )

  and prod = fun st -> st |> run (
    let prod-op =
      string `&&` >>
      return (fun t1 t2 -> Prod (t1, t2))
    in
    chainl enum prod-op
  )

  and compl = fun st -> st |> run (
    opt-with (fun t -> t) (
      char `^` >> return (fun t -> Not t)
    ) >>= (fun f -> (
      prod >>= (fun t -> (
        return (f t)
      ))
    ))
  )

  and class = fun st -> st |> run (
    compl << char `]`
  )

  and parse = fun st -> st |> run (
    char `[` >>
    class >>= build
  )

end


module Syntax : sig

  val re : node parser

end = struct

  let re-meta-char = `|?*+()[]^$.\`

  let item = none-of re-meta-char

  let char-class =
    CharClass.parse >>= (fun pred -> (
      return (Satisfy pred)
    ))

  let backslash-anchor =
    choice [
      char `b` >> return WordBoundary
    ; char `B` >> return NonWordBoundary
    ]

  let backslash =
    char `\` >>
    choice [
      control-char >>= (fun c -> (
        return (Char c)
      ))
    ; shorthand >>= (fun pred -> (
        return (Satisfy pred)
      ))
    ; backslash-anchor >>= (fun kind -> (
        return (Anchor kind)
      ))
    ; decimal >>= (fun n -> (
        return (BackRef n)
      ))
    ; any >>= (fun c -> (
        return (Char c)
      ))
    ]

  let single-meta =
    choice [
      char `.` >> return Any
    ; char `^` >> return (Anchor (BeginningOfLine))
    ; char `$` >> return (Anchor (EndOfLine))
    ]

  let-rec paren = fun st -> st |> run (
    char `(` >>
    choice [
      char `?` >>
        choice [
          char `=` >>
          alt >>= (fun t -> (
            return (LookAhead t)
          ))
        ; char `!` >>
          alt >>= (fun t -> (
            return (NegLookAhead t)
          ))
        ; char `>` >>
          alt >>= (fun t -> (
            return (Atomic t)
          ))
        ; char `:` >> alt
        ]
    ; alt >>= (fun t -> (
        return (Group t)
      ))
    ] << char `)`
  )

  and primary = fun st -> st |> run (
    choice [
      paren
    ; char-class
    ; backslash
    ; single-meta
    ; item >>= (fun c ->
        return (Char c)
      )
    ]
  )

  and rep-times t =
    char `{` >>
    choice [
      char `,` >>
      decimal >>= (fun n -> (
        return (AtMost n)
      ))
    ; decimal >>= (fun m -> (
        choice [
          char `,` >>
          choice [
            decimal >>= (fun n -> (
              return (Between (m, n))
            ))
          ; return (AtLeast m)
          ]
        ; return (Just m)
        ]
      ))
    ] << char `}`

  and quantifier builder =
    choice [
      char `?` >> return (builder Reluctant)
    ; char `+` >> return (builder Possessive)
    ; return (builder Greedy)
    ]

  and rep = fun st -> st |> run (
    primary >>= (fun t ->(
      choice [
        char `?` >> quantifier (fun q -> Opt (q, t))
      ; char `*` >> quantifier (fun q -> Many (q, t))
      ; char `+` >> quantifier (fun q -> Many1 (q, t))
      ; rep-times t >>= (fun kind -> (
          quantifier (fun q -> Repeat (kind, q, t))
        ))
      ; return t
      ]
    ))
  )

  and seq = fun st -> st |> run (
    many rep >>= (fun ts -> (
      return (Concat ts)
    ))
  )

  and alt = fun st -> st |> run (
    let alt-op =
      char `|` >> return (fun t1 t2 -> Alt (t1, t2))
    in
    chainl seq alt-op
  )

  and re = fun st -> st |> run (
    alt << eof
  )

end


module Exec : sig

  val run : inst Vec.t -> int -> (match-data list) parser

end = struct

  let increment-pc =
    get-state >>= (fun ctx -> (
      put-state (| ctx with pc = ctx#pc + 1 |)
    ))

  let set-pc pc =
    get-state >>= (fun ctx -> (
      put-state (| ctx with pc = pc |)
    ))

  let ensure len =
    get >>= (fun st -> (
      let srclen = string-length (Stream.source st) in
      if Stream.position st + len <= srclen then return ()
      else unexpected `end of input`
    ))

  let match1 c =
    char c >> return ()

  let any1 =
    any >> return ()

  let match1p pred =
    satisfy pred >> return ()

  let get-nth-match n =
    get-state >>= (fun ctx -> (
      let len = List.length ctx#matched in
      % let submatch = Option.from None (List.nth (len - 1 - n) ctx#matched) in
      let submatch = Option.from None (List.nth n ctx#matched) in
      return submatch
    ))

  let get-all-match =
    get-state >>= (fun ctx -> (
      % let matched = List.map (Option.from (0, 0, ` `)) ctx#matched in
      % return (List.reverse matched)
      return ctx#matched
    ))

  let list-nth-set n elem lst =
    let-rec iter k lst =
      match lst with
      | [] -> []
      | x :: xs ->
          if k == n then elem :: xs
          else x :: iter (k + 1) xs
    in
    iter 0 lst

  let set-match n bpos epos s =
    get-state >>= (fun ctx -> (
      % let len = List.length ctx#matched in
      % let matched = list-nth-set (len - 1 - n) (Some (bpos, epos, s)) ctx#matched in
      let matched = list-nth-set n (Some (bpos, epos, s)) ctx#matched in
      put-state (| ctx with matched = matched |)
    ))

  let push-current-pos =
    current-pos >>= (fun pos -> (
      get-state >>= (fun ctx -> (
        let pos-stack = pos :: ctx#pos-stack in
        put-state (| ctx with pos-stack = pos-stack |)
      ))
    ))

  let pop-pos =
    get-state >>= (fun ctx -> (
      match ctx#pos-stack with
      | [] -> problem `position stack is empty`
      | pos :: rest ->
          put-state (| ctx with pos-stack = rest |) >>
          return pos
    ))

  let capture n =
    get >>= (fun st -> (
      pop-pos >>= (fun pos -> (
        let curpos = Stream.position st in
        let sub = string-sub (Stream.source st) pos (curpos - pos) in
        set-match n pos curpos sub
      ))
    ))

  let anchor kind =
    match kind with
    | BeginningOfLine -> bof
    | EndOfLine -> eof
    | WordBoundary -> word-boundary
    | NonWordBoundary -> non-word-boundary

  let back-ref n =
    get-nth-match n >>= (fun submatch-opt -> (
      match submatch-opt with
      | None -> problem `matching group doesn't exist`
      | Some (_, _, s) -> string s >> return ()
    ))

  let fetch =
    get-state >>= (fun ctx -> (
      match Vec.get ctx#inst-seq ctx#pc with
      | None -> problem `invalid program counter`
      | Some inst -> return inst
    ))

  let-rec next = fun st -> st |> run (
    increment-pc >> exec
  )

  and jump pc = fun st -> st |> run (
    set-pc pc >> exec
  )

  and exec = fun st -> st |> run (
    fetch >>= (fun inst -> (
      match inst with
      | OpEmpty ->
          next
      | OpChar c ->
          ensure 1 >>
          match1 c >>
          next
      | OpAny ->
          ensure 1 >>
          any1 >>
          next
      | OpMatch ->
          capture 0 >>
          get-all-match
      | OpSplit (pc1, pc2) ->
          attempt (jump pc1) <|> jump pc2
      | OpJump pc ->
          jump pc
      | OpAtomicExec (pc1, pc2) ->
          jump pc1 >>
          jump pc2
      | OpStop ->
          return []
      | OpSaveStart ->
          push-current-pos >>
          next
      | OpSaveEnd n ->
          capture n >>
          next
      | OpSatisfy pred ->
          ensure 1 >>
          match1p pred >>
          next
      | OpAttempt (pc1, pc2) ->
          look-ahead (jump pc1) >>
          jump pc2
      | OpAttemptFail (pc1, pc2) ->
          not-followed-by (jump pc1) >>
          jump pc2
      | OpAnchor kind ->
          anchor kind >>
          next
      | OpBackRef n ->
          back-ref n >>
          next
    ))
  )

  let run inst-seq n-save =
    let ctx = (|
      regex-vm-init with
        inst-seq = inst-seq;
        matched = list-make (n-save + 1) None;
    |) in
    put-state ctx >>
    push-current-pos >>
    exec

end


module Regex : sig

  val compile : string -> (match-data list) parser

end = struct

  let build ast =
    let-mutable inst-seq <- Vec.empty in
    let emit inst = inst-seq <- Vec.push !inst-seq inst in
    let curpos () = Vec.size !inst-seq in
    let reserve () =
      let i = curpos () in
      let () = emit OpEmpty in
      fun inst -> (inst-seq <- Vec.set !inst-seq i inst)
    in
    let-mutable n-save <- 0 in
    let-rec iter node =
      match node with
      | Char c ->
          emit (OpChar c)
      | Any ->
          emit OpAny
      | Concat node-list ->
          List.iter iter node-list
      | Alt (t1, t2) ->
          let set-split = reserve () in
          let t1-begin = curpos () in
          let () = iter t1 in
          let set-jump = reserve () in
          let t2-begin = curpos () in
          let () = iter t2 in
          let () = set-split (OpSplit (t1-begin, t2-begin)) in
          set-jump (OpJump (curpos ()))
      | Opt (quantity, t) ->
          let emitter () =
            let set-split = reserve () in
            let t-begin = curpos () in
            let () = iter t in
            (set-split, t-begin)
          in
          emit-quantify emitter quantity
      | Many (quantity, t) ->
          let emitter () =
            let loop-begin = curpos () in
            let set-split = reserve () in
            let t-begin = curpos () in
            let () = iter t in
            let () = emit (OpJump loop-begin) in
            (set-split, t-begin)
          in
          emit-quantify emitter quantity
      | Many1 (quantity, t) ->
          let emitter () =
            let t-begin = curpos () in
            let () = iter t in
            let set-split = reserve () in
            (set-split, t-begin)
          in
          emit-quantify emitter quantity
      | Group t ->
          let () = n-save <- !n-save + 1 in
          let n = !n-save in
          let () = emit OpSaveStart in
          let () = iter t in
          emit (OpSaveEnd n)
      | Satisfy pred ->
          emit (OpSatisfy pred)
      | LookAhead t ->
          let set-attempt = reserve () in
          let t-begin = curpos () in
          let () = iter t in
          let () = emit OpStop in
          set-attempt (OpAttempt (t-begin, curpos ()))
      | NegLookAhead t ->
          let set-attempt-fail = reserve () in
          let t-begin = curpos () in
          let () = iter t in
          let () = emit OpStop in
          set-attempt-fail (OpAttemptFail (t-begin, curpos ()))
      | Anchor kind ->
          emit (OpAnchor kind)
      | BackRef n ->
          emit (OpBackRef n)
      | Repeat (kind, quantity, t) -> (
          match kind with
          | Just n ->
              for n (fun _ -> iter t)
          | AtLeast n ->
              let () = for n (fun _ -> iter t) in
              iter (Many (quantity, t))
          | AtMost n ->
              for n (fun _ -> iter (Opt (quantity, t)))
          | Between (m, n) ->
              let () = for m (fun _ -> iter t) in
              for (n - m) (fun _ -> iter (Opt (quantity, t)))
        )
      | Atomic t ->
          let set-atomic-exec = reserve () in
          let t-begin = curpos () in
          let () = iter t in
          let () = emit OpStop in
          set-atomic-exec (OpAtomicExec (t-begin, curpos ()))
    and emit-quantify emitter quantity =
      match quantity with
      | Greedy ->
          let (set-split, t-begin) = emitter () in
          set-split (OpSplit (t-begin, curpos ()))
      | Reluctant ->
          let (set-split, t-begin) = emitter () in
          set-split (OpSplit (curpos (), t-begin))
      | Possessive ->
          let set-atomic-exec = reserve () in
          let loop-begin = curpos () in
          let (set-split, t-begin) = emitter () in
          let () = set-split (OpSplit (t-begin, curpos ())) in
          let () = emit OpStop in
          set-atomic-exec (OpAtomicExec (loop-begin, curpos ()))
    in
    let () = iter ast in
    let () = emit OpMatch in
    Exec.run !inst-seq !n-save

  let string-make len c =
    let-rec iter acc k =
      if k == len then acc
      else iter (acc ^ c) (k + 1)
    in
    iter ` ` 0

  let compile pat =
    match parse Syntax.re None pat with
    | Ok ast -> build ast
    | Error err ->
        let display s = display-message (#`  `# ^ s) in
        let (unexp, exp, prob) = Error.format err in
        let pos = Error.position err in
        let () = display-message #` ---- ---- ---- ----`# in
        let () = display pat in
        let () = display (string-make pos #` `# ^ `^`) in
        let () = if string-same unexp ` ` then () else display unexp in
        let () = if string-same exp   ` ` then () else display exp in
        let () = if string-same prob  ` ` then () else display prob in
        abort-with-message (#`Parse error in character `# ^ arabic pos)

end
