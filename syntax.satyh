@import: style
@import: parser
@import: regex

open Parser


type color-ctx =
  | Empty
  | Simple of color
  | Nested of submatch list

and submatch = match-data * color-ctx

type continuation =
  | Done
  | Continue of rule list

and rule = (submatch list * continuation) regex-vm-ctx parser

type block-def = (|
  enter : rule;
  leave : rule;
  inner-style : style option;
  inner : rule list;
|)


module Syntax : sig

  val pattern : string -> rule
  val patterns : rule list -> rule
  val pattern-block : block-def -> rule
  val capture : int -> (submatch -> submatch) -> rule -> rule
  val style : style -> submatch -> submatch
  val include : rule -> submatch -> submatch
  val highlight : context -> rule list -> rule -> string -> inline-boxes * rule list

end = struct

  let pattern pat =
    let re = Regex.compile pat in
    re >>= (fun matched -> (
      let submatches = matched |> List.map (fun data -> (data, Empty)) in
      return (submatches, Done)
    ))

  let patterns = choice

  let list-rev-concat lst =
    lst |> List.reverse |> List.concat

  let pattern-block b =
    let-rec iter acc lpos = fun st -> st |> run (
      let color-ctx =
        match b#inner-style with
        | None -> Empty
        | Some tok -> Simple (ColorScheme.color-of tok)
      in
      let done acc =
        return (list-rev-concat acc, Done)
      in
      let continue acc stack =
        let p = current-pos >>= (iter []) in
        return (list-rev-concat acc, Continue (p :: stack))
      in
      let add-inner acc lpos rpos =
        get >>= (fun st -> (
          if lpos == rpos then return acc
          else
            let s = string-sub st#src lpos (rpos - lpos) in
            let inner = (Some (lpos, rpos, s), color-ctx) in
            return ([inner] :: acc)
        ))
      in
      current-pos >>= (fun rpos -> (
        choice [
          eof >>
          add-inner acc lpos rpos >>= (fun acc -> (
            continue acc []
          ))
        ; b#leave >>= (fun (submatches-leave, _) -> (
            add-inner acc lpos rpos >>= (fun acc -> (
              done (submatches-leave :: acc)
            ))
          ))
        ; choice b#inner >>= (fun (submatches-inner, k) -> (
            add-inner acc lpos rpos >>= (fun acc -> (
              match k with
              | Done -> (
                  current-pos >>= (fun lpos -> (
                    iter (submatches-inner :: acc) lpos
                  ))
                )
              | Continue stack ->
                  continue (submatches-inner :: acc) stack
            ))
          ))
        ; any >> iter acc lpos
        ]
      ))
    ) in
    b#enter >>= (fun (submatches-enter, _) -> (
      current-pos >>= (fun lpos -> (
        iter [submatches-enter] lpos
      ))
    ))

  let list-nth-map n f lst =
    let-rec iter k lst =
      match lst with
      | [] -> []
      | x :: xs ->
          if k == n then (f x) :: xs
          else x :: iter (k + 1) xs
    in
    iter 0 lst

  let capture n f p =
    p >>= (fun (submatches, k) -> (
      return (list-nth-map n f submatches, k)
    ))

  let style tok submatch =
    let (data, color-ctx) = submatch in
    (data, Simple (ColorScheme.color-of tok))

  let include rule submatch =
    let (data, color-ctx) = submatch in
    match data with
    | None -> submatch
    | Some (bpos, epos, s) -> (
        match parse regex-vm-ctx-init rule s with
        | None -> submatch
        | Some ((submatches, _), _) -> (data, Nested submatches)
      )

  let serialize submatches =
    let-rec iter acc offset submatches =
      match submatches with
      | [] -> acc
      | (None, _) :: rest -> iter acc offset rest
      | (Some (bpos, epos, s), color-ctx) :: rest -> (
          match color-ctx with
          | Empty ->
              let elem = (bpos + offset, epos + offset, s, None) in
              iter (elem :: acc) offset rest
          | Simple color ->
              let elem = (bpos + offset, epos + offset, s, Some color) in
              iter (elem :: acc) offset rest
          | Nested submatches ->
              let acc = iter acc (offset + bpos) submatches in
              iter acc offset rest
        )
    in
    iter [] 0 submatches |> List.reverse

  let take-subset rpos submatches =
    let-rec iter acc submatches =
      match submatches with
      | [] -> (List.reverse acc, [])
      | submatch :: rest ->
          let (_, epos, _, _) = submatch in
          if epos <= rpos then iter (submatch :: acc) rest
          else (List.reverse acc, submatches)
    in
    iter [] submatches

  let set-text-color-opt color-opt ctx =
    match color-opt with
    | None -> ctx
    | Some color -> ctx |> set-text-color color

  let build-ib ctx src lpos rpos =
    if lpos == rpos then inline-nil
    else
      let s = string-sub src lpos (rpos - lpos) in
      read-inline ctx (embed-string s)

  let build-colored-ib ctx src submatches =
    let-rec iter ctx acc lpos rpos submatches =
      match submatches with
      | [] ->
          let ib-rest = build-ib ctx src lpos rpos in
          acc ++ ib-rest
      | (bpos, epos, _, color-opt) :: rest ->
          let ib-left = build-ib ctx src lpos bpos in
          let (subset, rest1) = take-subset epos rest in
          let ctx1 = ctx |> set-text-color-opt color-opt in
          let ib-mid = iter ctx1 inline-nil bpos epos subset in
          iter ctx (acc ++ ib-left ++ ib-mid) epos rpos rest1
    in
    iter ctx inline-nil 0 (string-length src) submatches

  % for debugging
  let print-submatches submatches =
    let-rec print submatch =
      let (bpos, epos, s, _) = submatch in
      let pos = arabic bpos ^ `-` ^ arabic epos in
      let msg = `[` ^ s ^ `:` ^ pos ^ `]` in
      display-message msg
    in
    let () = List.iter print submatches in submatches

  let highlight ctx stack-init rule code =
    let p-line =
      let-rec iter acc stack = fun st -> st |> run (
        choice [
          eof >>
          return (list-rev-concat acc, stack)
        ; ( match stack with
            | [] -> (
                rule >>= (fun (submatches, k) -> (
                  match k with
                  | Done -> iter (submatches :: acc) []
                  | Continue stack1 -> iter (submatches :: acc) stack1
                ))
              )
            | top :: rest -> (
                top >>= (fun (submatches, k) -> (
                  match k with
                  | Done -> iter (submatches :: acc) rest
                  | Continue stack1 -> iter (submatches :: acc) (list-rev-append stack1 rest)
                ))
              )
          )
        ; any >> iter acc stack
        ]
      ) in iter [] stack-init
    in
    match parse regex-vm-ctx-init p-line code with
    | None ->
        (read-inline ctx (embed-string code), stack-init)
    | Some ((submatches, stack), st) -> (
        let ib =
          serialize submatches
            |> print-submatches
            |> build-colored-ib ctx st#src
        in
        (ib, stack)
      )

end
