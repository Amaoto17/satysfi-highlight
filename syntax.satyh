@import: style
@import: parser
@import: regex

open Parser


module Syntax : sig

  type submatch
  type rule

  val run : 'a 'u parser -> 'u state -> ('a * 'u state) option % for eta expansion
  val pattern : string -> rule
  val patterns : rule list -> rule
  val pattern-block : 'a -> rule
    constraint 'a :: (|
      enter : rule;
      leave : rule;
      style : style option;
      inner : rule list;
    |)
  val capture : int -> (submatch -> submatch) -> rule -> rule
  val style : style -> submatch -> submatch
  val include : rule -> submatch -> submatch
  val highlight : context -> rule list -> rule -> string -> inline-boxes * rule list

end = struct

  type color-ctx =
    | Empty
    | Simple of color
    | Nested of submatch list

  and submatch = match-data * color-ctx

  type continuation =
    | Done
    | Continue of rule list

  and rule = (submatch list * continuation) regex-vm-ctx parser
  

  let run = Parser.run

  let pattern pat =
    let re = Regex.compile pat in
    re >>= (fun matched -> (
      let submatches = matched |> List.map (fun data -> (data, Empty)) in
      return (submatches, Done)
    ))

  let patterns = choice

  let list-rev-concat lst =
    lst |> List.reverse |> List.concat

  let pattern-block b =
    let color-ctx =
      match b#style with
      | None -> Empty
      | Some tok -> Simple (ColorScheme.color-of tok)
    in
    let-rec iter acc lpos = fun st -> st |> run (
      let entire-match =
        current-pos >>= (fun rpos -> (
          if lpos == rpos then return []
          else
            let s = string-sub st#src lpos (rpos - lpos) in
            return [(Some (lpos, rpos, s), color-ctx)]
        ))
      in
      let done acc =
        entire-match >>= (fun entire -> (
          let submatches = List.concat (entire :: (List.reverse acc)) in
          return (submatches, Done)
        ))
      in
      let continue acc stack =
        entire-match >>= (fun entire -> (
          let p = current-pos >>= (iter []) in
          let submatches = List.concat (entire :: (List.reverse acc)) in
          return (submatches, Continue (p :: stack))
        ))
      in
      choice [
        eof >> continue acc []
      ; b#leave >>= (fun (submatches-leave, _) -> (
          done (submatches-leave :: acc)
        ))
      ; choice b#inner >>= (fun (submatches-inner, k) -> (
          match k with
          | Done ->
              iter (submatches-inner :: acc) lpos
          | Continue stack ->
              continue (submatches-inner :: acc) stack
        ))
      ; any >> iter acc lpos
      ]
    ) in
    current-pos >>= (fun lpos -> (
      b#enter >>= (fun (submatches-enter, _) -> (
        iter [submatches-enter] lpos
      ))
    ))

  let list-nth-map n f lst =
    let-rec iter k lst =
      match lst with
      | [] -> []
      | x :: xs ->
          if k == n then (f x) :: xs
          else x :: iter (k + 1) xs
    in
    iter 0 lst

  let capture n f p =
    p >>= (fun (submatches, k) -> (
      return (list-nth-map n f submatches, k)
    ))

  let style sty submatch =
    let (data, color-ctx) = submatch in
    (data, Simple (ColorScheme.color-of sty))

  let include rule submatch =
    let p =
      let-rec iter acc = fun st -> st |> run (
        choice [
          eof >> return (list-rev-concat acc)
        ; rule >>= (fun (submatches, k) -> (
            match k with
            | Done -> iter (submatches :: acc)
            | Continue _ -> iter acc
          ))
        ; any >> iter acc
        ]
      ) in iter []
    in
    let (data, color-ctx) = submatch in
    match data with
    | None -> submatch
    | Some (bpos, epos, s) -> (
        match parse regex-vm-ctx-init p s with
        | None -> submatch
        | Some (submatches, _) -> (data, Nested submatches)
      )

  let serialize submatches =
    let-rec iter acc offset submatches =
      match submatches with
      | [] -> acc
      | (None, _) :: rest -> iter acc offset rest
      | (Some (bpos, epos, s), color-ctx) :: rest -> (
          match color-ctx with
          | Empty ->
              let elem = (bpos + offset, epos + offset, s, None) in
              iter (elem :: acc) offset rest
          | Simple color ->
              let elem = (bpos + offset, epos + offset, s, Some color) in
              iter (elem :: acc) offset rest
          | Nested submatches ->
              let acc = iter acc (offset + bpos) submatches in
              iter acc offset rest
        )
    in
    iter [] 0 submatches |> List.reverse

  let take-subset rpos submatches =
    let-rec iter acc submatches =
      match submatches with
      | [] -> (List.reverse acc, [])
      | submatch :: rest ->
          let (_, epos, _, _) = submatch in
          if epos <= rpos then iter (submatch :: acc) rest
          else (List.reverse acc, submatches)
    in
    iter [] submatches

  let set-text-color-opt color-opt ctx =
    match color-opt with
    | None -> ctx
    | Some color -> ctx |> set-text-color color

  let build-ib ctx src lpos rpos =
    if lpos == rpos then inline-nil
    else
      let s = string-sub src lpos (rpos - lpos) in
      read-inline ctx (embed-string s)

  let build-colored-ib ctx src submatches =
    let-rec iter ctx acc lpos rpos submatches =
      match submatches with
      | [] ->
          let ib-rest = build-ib ctx src lpos rpos in
          acc ++ ib-rest
      | (bpos, epos, _, color-opt) :: rest ->
          let ib-left = build-ib ctx src lpos bpos in
          let (subset, rest1) = take-subset epos rest in
          let ctx1 = ctx |> set-text-color-opt color-opt in
          let ib-mid = iter ctx1 inline-nil bpos epos subset in
          iter ctx (acc ++ ib-left ++ ib-mid) epos rpos rest1
    in
    iter ctx inline-nil 0 (string-length src) submatches

  % for debugging
  let print-submatches submatches =
    let-rec print submatch =
      let (bpos, epos, s, _) = submatch in
      let pos = arabic bpos ^ `-` ^ arabic epos in
      let msg = `[` ^ s ^ `:` ^ pos ^ `]` in
      display-message msg
    in
    let () = display-message ` ` in
    let () = List.iter print submatches in submatches

  let highlight ctx stack-init rule code =
    let p-line =
      let-rec iter acc stack = fun st -> st |> run (
        choice [
          eof >> return (list-rev-concat acc, stack)
        ; ( match stack with
            | [] -> (
                rule >>= (fun (submatches, k) -> (
                  match k with
                  | Done -> iter (submatches :: acc) []
                  | Continue stack1 -> iter (submatches :: acc) stack1
                ))
              )
            | top :: rest -> (
                top >>= (fun (submatches, k) -> (
                  match k with
                  | Done -> iter (submatches :: acc) rest
                  | Continue stack1 -> iter (submatches :: acc) (list-rev-append stack1 rest)
                ))
              )
          )
        ; any >> iter acc stack
        ]
      ) in iter [] stack-init
    in
    match parse regex-vm-ctx-init p-line code with
    | None ->
        (read-inline ctx (embed-string code), stack-init)
    | Some ((submatches, stack), st) -> (
        let ib =
          serialize submatches
            % |> print-submatches
            |> build-colored-ib ctx st#src
        in
        (ib, stack)
      )

end
