@require: option
@import: hl-vector
@import: hl-parser
@import: hl-utils

open Parser


type quantity =
  | Greedy
  | Reluctant
  | Possessive


type node =
  | Char of string
  | Concat of node list
  | Alt of node * node
  | Opt of quantity * node
  | Many of quantity * node
  | Many1 of quantity * node
  | Group of node
  | Satisfy of string -> bool


type inst =
  | OpEmpty
  | OpChar of string
  | OpMatch
  | OpSplit of int * int
  | OpJump of int
  | OpAtomicExec of int * int
  | OpStop
  | OpSaveStart
  | OpSaveEnd of int
  | OpSatisfy of string -> bool


type exec-ctx = (|
  inst-seq : inst Vec.vec;
  pc : int;
  pos-stack : int list;
  matched : ((int * int * string) option) list;
|)

let exec-ctx-init = (|
  inst-seq = Vec.empty;
  pc = 0;
  pos-stack = [];
  matched = [];
|)


let control-char =
  choice [
    char `n` >> return (string-unexplode [12])
  ; char `t` >> return (string-unexplode [11])
  ; char `r` >> return (string-unexplode [15])
  ]

let shorthand =
  choice [
    char `w` >> return is-word-char
  ]


module CharClass : sig

  val parse : (string -> bool) unit parser

end = struct

  let string-index s init-pos c =
    let-rec iter k =
      if k == string-length s then -1
      else
        let c1 = string-sub s k 1 in
        if string-same c1 c then k else iter (k + 1)
    in
    iter init-pos


  let lower = `abcdefghijklmnopqrstuvwxyz`
  let upper = `ABCDEFGHIJKLMNOPQRSTUVWXYZ`
  let number = `0123456789`

  let option-is-some opt =
    match opt with
    | Some _ -> true
    | None   -> false

  let string-between c1 c2 =
    let aux group =
      let pos1 = string-index group 0 c1 in
      if pos1 == -1 then None
      else
        let pos2 = string-index group pos1 c2 in
        if pos2 == -1 then None
        else Some (string-sub group pos1 (pos2 - pos1 + 1))
    in
    let str-opt = aux lower in
    if option-is-some str-opt then str-opt
    else let str-opt = aux upper in
    if option-is-some str-opt then str-opt
    else aux number


  type class-node =
    | Class of class-node
    | Single of string
    | Range of string * string
    | Shorthand of string -> bool
    | Union of class-node * class-node
    | Prod of class-node * class-node
    | Not of class-node

  
  let build ast =
    let-rec iter node =
      match node with
      | Single c -> string-same c
      | Range (c1, c2) -> (
          match string-between c1 c2 with
          | None -> fun _ -> false
          | Some str -> string-contains str
        )
      | Class t -> iter t
      | Shorthand pred -> pred
      | Not t -> fun x -> not (iter t x)
      | Prod (t1, t2) -> fun x -> iter t1 x && iter t2 x
      | Union (t1, t2) -> fun x -> iter t1 x || iter t2 x
    in
    return (iter ast)


  let class-meta-char = `[]&-\`

  let item = none-of class-meta-char

  let-rec escaped = fun st -> st |> run (
    char `\` >>
    choice [
      control-char >>= (fun c -> (
        return (Single c)
      ))
    ; shorthand >>= (fun pred -> (
        return (Shorthand pred)
      ))
    ; any >>= (fun c -> (
        return (Single c)
      ))
    ]
  )

  and range c1 =
    char `-` >>
    item >>= (fun c2 -> (
      return (Range (c1, c2))
    ))

  and primary = fun st -> st |> run (
    choice [
      char `[` >>
      class >>= (fun t -> (
        return (Class t)
      ))
    ; escaped
    ; item >>= (fun c -> (
        (range c) <|> return (Single c)
      ))
    ]
  )

  and enum = fun st -> st |> run (
    let enum-op =
      return (fun t1 t2 -> Union (t1, t2))
    in
    chainl primary enum-op
  )

  and prod = fun st -> st |> run (
    let prod-op =
      string `&&` >>
      return (fun t1 t2 -> Prod (t1, t2))
    in
    chainl enum prod-op
  )

  and compl = fun st -> st |> run (
    opt-with (fun t -> t) (
      char `^` >> return (fun t -> Not t)
    ) >>= (fun f -> (
      prod >>= (fun t -> (
        return (f t)
      ))
    ))
  )

  and class = fun st -> st |> run (
    compl << char `]`
  )

  and parse = fun st -> st |> run (
    char `[` >>
    class >>= build
  )

end


module Syntax : sig

  val re : node unit parser

end = struct

  let re-meta-char = `|?*+()`

  let item = none-of re-meta-char

  let char-class =
    CharClass.parse >>= (fun pred -> (
      return (Satisfy pred)
    ))

  let-rec paren = fun st -> st |> run (
    char `(` >>
    choice [
      alt >>= (fun t -> (
        return (Group t)
      ))
    ] << char `)`
  )

  and primary = fun st -> st |> run (
    choice [
      paren
    ; char-class
    ; item >>= (fun c ->
        return (Char c)
      )
    ]
  )

  and quantifier builder =
    choice [
      char `?` >> return (builder Reluctant)
    ; char `+` >> return (builder Possessive)
    ; return (builder Greedy)
    ]

  and rep = fun st -> st |> run (
    primary >>= (fun t ->(
      choice [
        char `?` >> quantifier (fun q -> Opt (q, t))
      ; char `*` >> quantifier (fun q -> Many (q, t))
      ; char `+` >> quantifier (fun q -> Many1 (q, t))
      ; return t
      ]
    ))
  )

  and seq = fun st -> st |> run (
    many rep >>= (fun ts -> (
      return (Concat ts)
    ))
  )

  and alt = fun st -> st |> run (
    let alt-op =
      char `|` >> return (fun t1 t2 -> Alt (t1, t2))
    in
    chainl seq alt-op
  )

  and re = fun st -> st |> run (
    alt << eof
  )

end


module Exec : sig

  val run : inst Vec.vec -> ((int * int * string) list) exec-ctx parser

end = struct

  let increment-pc =
    get-state >>= (fun ctx -> (
      put-state (| ctx with pc = ctx#pc + 1 |)
    ))

  let set-pc pc =
    get-state >>= (fun ctx -> (
      put-state (| ctx with pc = pc |)
    ))

  let ensure len =
    get >>= (fun st -> (
      let srclen = string-length st#src in
      if st#offset + len <= srclen then return ()
      else fail
    ))

  let match1 c =
    char c >> return ()

  let match1p pred =
    satisfy pred >> return ()

  let get-all-match =
    get-state >>= (fun ctx -> (
      let matched = List.map (Option.from (0, 0, ` `)) ctx#matched in
      return (List.reverse matched)
      % return ctx#matched
    ))

  let list-nth-set n elem lst =
    let-rec iter k lst =
      match lst with
      | [] -> []
      | x :: xs ->
          if k == n then elem :: xs
          else x :: iter (k + 1) xs
    in
    iter 0 lst

  let set-match n bpos epos s =
    get-state >>= (fun ctx -> (
      let len = List.length ctx#matched in
      let matched = list-nth-set (len - 1 - n) (Some (bpos, epos, s)) ctx#matched in
      put-state (| ctx with matched = matched |)
      % put-state (| ctx with matched = (bpos, epos, s) :: ctx#matched |)
    ))

  let push-current-pos =
    current-pos >>= (fun pos -> (
      get-state >>= (fun ctx -> (
        let pos-stack = pos :: ctx#pos-stack in
        let matched = None :: ctx#matched in
        put-state (| ctx with pos-stack = pos-stack; matched = matched |)
      ))
    ))

  let pop-pos =
    get-state >>= (fun ctx -> (
      match ctx#pos-stack with
      | [] -> fail
      | pos :: rest ->
          put-state (| ctx with pos-stack = rest |) >>
          return pos
    ))

  let capture n =
    get >>= (fun st -> (
      pop-pos >>= (fun pos -> (
        let curpos = st#offset in
        let sub = string-sub st#src pos (curpos - pos) in
        set-match n pos curpos sub
        % add-match pos curpos sub
      ))
    ))

  % let fetch =
  %   get-state >>= (fun ctx -> (
  %     match List.nth ctx#pc ctx#inst-seq with
  %     | None -> fail
  %     | Some inst -> return inst 
  %   ))

  let fetch =
    get-state >>= (fun ctx -> (
      match Vec.get ctx#inst-seq ctx#pc with
      | None -> fail
      | Some inst -> return inst
    ))

  let-rec next = fun st -> st |> run (
    increment-pc >> exec
  )

  and jump pc = fun st -> st |> run (
    set-pc pc >> exec
  )

  and split pc1 pc2 = fun st -> (
    match st |> jump pc1 with
    | Some x -> Some x
    | None -> st |> jump pc2
  )

  and exec = fun st -> st |> run (
    fetch >>= (fun inst -> (
      match inst with
      | OpEmpty ->
          next
      | OpChar c ->
          ensure 1 >>
          match1 c >>
          next
      | OpMatch ->
          capture 0 >>
          get-all-match
      | OpSplit (pc1, pc2) ->
          split pc1 pc2
      | OpJump pc ->
          jump pc
      | OpAtomicExec (pc1, pc2) ->
          jump pc1 >>
          jump pc2
      | OpStop ->
          return []
      | OpSaveStart ->
          push-current-pos >>
          next
      | OpSaveEnd n ->
          capture n >>
          next
      | OpSatisfy pred ->
          ensure 1 >>
          match1p pred >>
          next
    ))
  )

  let run inst-seq =
    let ctx = (| exec-ctx-init with inst-seq = inst-seq |) in
    put-state ctx >>
    push-current-pos >>
    exec

end


module Regex : sig

  val compile : string -> ((int * int * string) list) exec-ctx parser

end = struct

  let build ast =
    let-mutable inst-seq <- Vec.empty in
    let emit inst = inst-seq <- Vec.push !inst-seq inst in
    let curpos () = Vec.size !inst-seq in
    let reserve () =
      let i = curpos () in
      let () = emit OpEmpty in
      fun inst -> (inst-seq <- Vec.set !inst-seq i inst)
    in
    let-mutable n-save <- 0 in
    let-rec iter node =
      match node with
      | Char c ->
          emit (OpChar c)
      | Concat node-list ->
          List.iter iter node-list
      | Alt (t1, t2) ->
          let set-split = reserve () in
          let t1-begin = curpos () in
          let () = iter t1 in
          let set-jump = reserve () in
          let t2-begin = curpos () in
          let () = iter t2 in
          let () = set-split (OpSplit (t1-begin, t2-begin)) in
          set-jump (OpJump (curpos ()))
      | Opt (quantity, t) ->
          let emitter () =
            let set-split = reserve () in
            let t-begin = curpos () in
            let () = iter t in
            (set-split, t-begin)
          in
          emit-quantify emitter quantity
      | Many (quantity, t) ->
          let emitter () =
            let loop-begin = curpos () in
            let set-split = reserve () in
            let t-begin = curpos () in
            let () = iter t in
            let () = emit (OpJump loop-begin) in
            (set-split, t-begin)
          in
          emit-quantify emitter quantity
      | Many1 (quantity, t) ->
          let emitter () =
            let t-begin = curpos () in
            let () = iter t in
            let set-split = reserve () in
            (set-split, t-begin)
          in
          emit-quantify emitter quantity
      | Group t ->
          let () = n-save <- !n-save + 1 in
          let n = !n-save in
          let () = emit OpSaveStart in
          let () = iter t in
          emit (OpSaveEnd n)
      | Satisfy pred ->
          emit (OpSatisfy pred)
    and emit-quantify emitter quantity =
      match quantity with
      | Greedy ->
          let (set-split, t-begin) = emitter () in
          set-split (OpSplit (t-begin, curpos ()))
      | Reluctant ->
          let (set-split, t-begin) = emitter () in
          set-split (OpSplit (curpos (), t-begin))
      | Possessive ->
          let set-atomic-exec = reserve () in
          let loop-begin = curpos () in
          let (set-split, t-begin) = emitter () in
          let () = set-split (OpSplit (t-begin, curpos ())) in
          let () = emit OpStop in
          set-atomic-exec (OpAtomicExec (loop-begin, curpos ()))
    in
    let () = iter ast in
    let () = emit OpMatch in
    Exec.run !inst-seq

  let compile pat =
    match easy-parse Syntax.re pat with
    | Some ast -> build ast
    | None -> fail

end
