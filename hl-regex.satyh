@require: option
@import: hl-vector
@import: hl-parser

open Parser


type quantity =
  | Greedy
  | Reluctant
  | Possessive


type node =
  | Char of string
  | Concat of node list
  | Alt of node * node
  | Opt of quantity * node
  | Many of quantity * node
  | Many1 of quantity * node


type inst =
  | OpEmpty
  | OpChar of string
  | OpMatch
  | OpSplit of int * int
  | OpJump of int
  | OpAtomicExec of int * int
  | OpStop


type exec-ctx = (|
  inst-seq : inst Vec.vec;
  pc : int;
  pos-stack : int list;
  matched : string list;
|)

let exec-ctx-init = (|
  inst-seq = Vec.empty;
  pc = 0;
  pos-stack = [];
  matched = [];
|)


module Syntax : sig

  val re : node 'u parser

end = struct

  let re-meta-char = `|?*+`

  let item = none-of re-meta-char

  let-rec primary = fun st -> st |> run (
    item >>= (fun c ->
      return (Char c)
    )
  )

  and quantifier builder =
    choice [
      char `?` >> return (builder Reluctant)
    ; char `+` >> return (builder Possessive)
    ; return (builder Greedy)
    ]

  and rep = fun st -> st |> run (
    primary >>= (fun t ->(
      choice [
        char `?` >> quantifier (fun q -> Opt (q, t))
      ; char `*` >> quantifier (fun q -> Many (q, t))
      ; char `+` >> quantifier (fun q -> Many1 (q, t))
      ; return t
      ]
    ))
  )

  and seq = fun st -> st |> run (
    many rep >>= (fun ts -> (
      return (Concat ts)
    ))
  )

  and alt = fun st -> st |> run (
    let alt-op =
      char `|` >> return (fun t1 t2 -> Alt (t1, t2))
    in
    chainl seq alt-op
  )

  and re = fun st -> st |> run (
    alt << eof
  )

end


module Exec : sig

  val run : inst Vec.vec -> (string list) exec-ctx parser

end = struct

  let increment-pc =
    get-state >>= (fun ctx -> (
      put-state (| ctx with pc = ctx#pc + 1 |)
    ))

  let set-pc pc =
    get-state >>= (fun ctx -> (
      put-state (| ctx with pc = pc |)
    ))

  let ensure len =
    get >>= (fun st -> (
      let srclen = string-length st#src in
      if st#offset + len <= srclen then return ()
      else fail
    ))

  let match1 c =
    char c >> return ()

  let get-all-match =
    get-state >>= (fun ctx -> (
      return ctx#matched
    ))

  let add-match s =
    get-state >>= (fun ctx -> (
      put-state (| ctx with matched = s :: ctx#matched |)
    ))

  let push-current-pos =
    current-pos >>= (fun pos -> (
      get-state >>= (fun ctx -> (
        put-state (| ctx with pos-stack = pos :: ctx#pos-stack |)
      ))
    ))

  let pop-pos =
    get-state >>= (fun ctx -> (
      match ctx#pos-stack with
      | [] -> fail
      | pos :: rest ->
          put-state (| ctx with pos-stack = rest |) >>
          return pos
    ))

  let capture =
    get >>= (fun st -> (
      pop-pos >>= (fun pos -> (
        let curpos = st#offset in
        let sub = string-sub st#src pos (curpos - pos) in
        add-match sub
      ))
    ))

  % let fetch =
  %   get-state >>= (fun ctx -> (
  %     match List.nth ctx#pc ctx#inst-seq with
  %     | None -> fail
  %     | Some inst -> return inst 
  %   ))

  let fetch =
    get-state >>= (fun ctx -> (
      match Vec.get ctx#inst-seq ctx#pc with
      | None -> fail
      | Some inst -> return inst
    ))

  let-rec next = fun st -> st |> run (
    increment-pc >> exec
  )

  and jump pc = fun st -> st |> run (
    set-pc pc >> exec
  )

  and split pc1 pc2 = fun st -> (
    match st |> jump pc1 with
    | Some x -> Some x
    | None -> st |> jump pc2
  )

  and exec = fun st -> st |> run (
    fetch >>= (fun inst -> (
      match inst with
      | OpEmpty ->
          next
      | OpChar c ->
          ensure 1 >>
          match1 c >>
          next
      | OpMatch ->
          capture >>
          get-all-match
      | OpSplit (pc1, pc2) ->
          split pc1 pc2
      | OpJump pc ->
          jump pc
      | OpAtomicExec (pc1, pc2) ->
          jump pc1 >>
          jump pc2
      | OpStop ->
          return []
    ))
  )

  let run inst-seq =
    let ctx = (| exec-ctx-init with inst-seq = inst-seq |) in
    put-state ctx >>
    push-current-pos >>
    exec |> map (fun matched -> (
      match matched with
      | [] -> []
      | x :: xs -> x :: List.reverse xs
    ))

end


module Regex : sig

  val compile : string -> (string list) exec-ctx parser

end = struct

  let dummy = ()

  let build ast =
    let-mutable inst-seq <- Vec.empty in
    let emit inst = inst-seq <- Vec.push !inst-seq inst in
    let curpos () = Vec.size !inst-seq in
    let reserve () =
      let i = curpos () in
      let () = emit OpEmpty in
      fun inst -> (inst-seq <- Vec.set !inst-seq i inst)
    in
    let-rec iter node =
      match node with
      | Char c ->
          emit (OpChar c)
      | Concat node-list ->
          List.iter iter node-list
      | Alt (t1, t2) ->
          let set-split = reserve () in
          let t1-begin = curpos () in
          let () = iter t1 in
          let set-jump = reserve () in
          let t2-begin = curpos () in
          let () = iter t2 in
          let () = set-split (OpSplit (t1-begin, t2-begin)) in
          set-jump (OpJump (curpos ()))
      | Opt (quantity, t) ->
          let emitter () =
            let set-split = reserve () in
            let t-begin = curpos () in
            let () = iter t in
            (set-split, t-begin)
          in
          emit-quantify emitter quantity
      | Many (quantity, t) ->
          let emitter () =
            let loop-begin = curpos () in
            let set-split = reserve () in
            let t-begin = curpos () in
            let () = iter t in
            let () = emit (OpJump loop-begin) in
            (set-split, t-begin)
          in
          emit-quantify emitter quantity
      | Many1 (quantity, t) ->
          let emitter () =
            let t-begin = curpos () in
            let () = iter t in
            let set-split = reserve () in
            (set-split, t-begin)
          in
          emit-quantify emitter quantity
    and emit-quantify emitter quantity =
      match quantity with
      | Greedy ->
          let (set-split, t-begin) = emitter () in
          set-split (OpSplit (t-begin, curpos ()))
      | Reluctant ->
          let (set-split, t-begin) = emitter () in
          set-split (OpSplit (curpos (), t-begin))
      | Possessive ->
          let set-atomic-exec = reserve () in
          let loop-begin = curpos () in
          let (set-split, t-begin) = emitter () in
          let () = set-split (OpSplit (t-begin, curpos ())) in
          let () = emit OpStop in
          set-atomic-exec (OpAtomicExec (loop-begin, curpos ()))
    in
    let () = iter ast in
    let () = emit OpMatch in
    Exec.run !inst-seq

  let compile pat =
    match easy-parse Syntax.re pat with
    | Some ast -> build ast
    | None -> fail

end
