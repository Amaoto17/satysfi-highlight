@require: option
@import: hl-parser

open Parser


type node =
  | Char of string
  | Concat of node list
  | Alt of node * node


type inst =
  | OpChar of string
  | OpMatch
  | OpSplit of int * int
  | OpJump of int


type exec-ctx = (|
  inst-seq : inst list;
  pc : int;
  pos-stack : int list;
  matched : string list;
|)

let exec-ctx-init = (|
  inst-seq = [];
  pc = 0;
  pos-stack = [];
  matched = [];
|)


module Syntax : sig

  val re : node 'u parser

end = struct

  let re-meta-char = `|`

  let item = none-of re-meta-char

  let primary = fun st -> st |> run (
    item >>= (fun c ->
      return (Char c)
    )
  )

  let seq = fun st -> st |> run (
    many primary >>= (fun ts -> (
      return (Concat ts)
    ))
  )

  let alt = fun st -> st |> run (
    let alt-op =
      char `|` >> return (fun t1 t2 -> Alt (t1, t2))
    in
    chainl seq alt-op
  )

  let re = fun st -> st |> run (
    alt << eof
  )

end


module Exec : sig

  val run : inst list -> (string list) exec-ctx parser

end = struct

  let add-pc d =
    get-state >>= (fun ctx -> (
      put-state (| ctx with pc = ctx#pc + d |)
    ))

  let ensure len =
    get >>= (fun st -> (
      let srclen = string-length st#src in
      if st#offset + len <= srclen then return ()
      else fail
    ))

  let match1 c =
    char c >> return ()

  let get-all-match =
    get-state >>= (fun ctx -> (
      return ctx#matched
    ))

  let add-match s =
    get-state >>= (fun ctx -> (
      put-state (| ctx with matched = s :: ctx#matched |)
    ))

  let push-current-pos =
    current-pos >>= (fun pos -> (
      get-state >>= (fun ctx -> (
        put-state (| ctx with pos-stack = pos :: ctx#pos-stack |)
      ))
    ))

  let pop-pos =
    get-state >>= (fun ctx -> (
      match ctx#pos-stack with
      | [] -> fail
      | pos :: rest ->
          put-state (| ctx with pos-stack = rest |) >>
          return pos
    ))

  let capture =
    get >>= (fun st -> (
      pop-pos >>= (fun pos -> (
        let curpos = st#offset in
        let sub = string-sub st#src pos (curpos - pos) in
        add-match sub
      ))
    ))

  let fetch =
    get-state >>= (fun ctx -> (
      match List.nth ctx#pc ctx#inst-seq with
      | None -> fail
      | Some inst -> return inst 
    ))

  let-rec next = fun st -> st |> run (
    add-pc 1 >> exec
  )

  and jump diff = fun st -> st |> run (
    add-pc diff >> exec
  )

  and split d1 d2 = fun st -> (
    match st |> jump d1 with
    | Some x -> Some x
    | None -> st |> jump d2
  )

  and exec = fun st -> st |> run (
    fetch >>= (fun inst -> (
      match inst with
      | OpChar c ->
          ensure 1 >>
          match1 c >>
          next
      | OpMatch ->
          capture >>
          get-all-match
      | OpSplit (d1, d2) ->
          split d1 d2
      | OpJump d ->
          jump d
    ))
  )

  let run inst-seq =
    let ctx = (| exec-ctx-init with inst-seq = inst-seq |) in
    put-state ctx >>
    push-current-pos >>
    exec |> map (fun matched -> (
      match matched with
      | [] -> []
      | x :: xs -> x :: List.reverse xs
    ))

end


module Regex : sig

  val compile : string -> (string list) exec-ctx parser

end = struct

  let dummy = ()

  let build ast =
    let-rec iter node =
      match node with
      | Char c ->
          [OpChar c]
      | Concat node-list ->
          List.map iter node-list |> List.concat
      | Alt (t1, t2) ->
          let code-t1 = iter t1 in
          let code-t2 = iter t2 in
          let len-t1 = List.length code-t1 in
          let len-t2 = List.length code-t2 in
          List.append
            (OpSplit (1, len-t1 + 2) :: code-t1)
            (OpJump (len-t2 + 1) :: code-t2)
    in
    let inst-seq = List.append (iter ast) [OpMatch] in
    Exec.run inst-seq

  let compile pat =
    match easy-parse Syntax.re pat with
    | Some ast -> build ast
    | None -> fail

end
