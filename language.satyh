@import: token
@import: parser
@import: regex


module Language : sig

  type item
  type rule

  val pattern : string -> rule
  val patterns : rule list -> rule
  val capture : int -> (item -> item) -> rule -> rule
  val token : token -> item -> item
  val include : rule -> item -> item
  val scan : context -> rule -> string -> inline-boxes

end = struct

  type color-ctx =
    | Empty
    | Simple of color
    | Nested of item list

  and item = match-data * color-ctx

  type rule = (item list) exec-ctx parser

  let pattern pat =
    let p = Regex.compile pat in
    p >>= (fun matched -> (
      let item-list = matched |> List.map (fun data -> (data, Empty)) in
      return item-list
    ))

  let patterns = choice

  let list-nth-map n f lst =
    let-rec iter k lst =
      match lst with
      | [] -> []
      | x :: xs ->
          if k == n then (f x) :: xs
          else x :: iter (k + 1) xs
    in
    iter 0 lst

  let capture n f t =
    t >>= (fun item-list -> (
      return (list-nth-map n f item-list)
    ))

  let token tok item =
    let (data, color-ctx) = item in
    (data, Simple (ColorScheme.color-of tok))

  let include rule item =
    let (data, color-ctx) = item in
    match data with
    | None -> item
    | Some (bpos, epos, s) -> (
        match parse exec-ctx-init rule s with
        | None -> item
        | Some (item-list, _) -> (data, Nested item-list)
      )

  let serialize-item-list item-list =
    let-rec iter acc offset item-list =
      match item-list with
      | [] -> acc
      | (None, _) :: rest -> iter acc offset rest
      | (Some (bpos, epos, s), color-ctx) :: rest -> (
          match color-ctx with
          | Empty ->
              let elem = (bpos + offset, epos + offset, s, None) in
              iter (elem :: acc) offset rest
          | Simple color ->
              let elem = (bpos + offset, epos + offset, s, Some color) in
              iter (elem :: acc) offset rest
          | Nested item-list ->
              let acc = iter acc (offset + bpos) item-list in
              iter acc offset rest
        )
    in
    iter [] 0 item-list |> List.reverse

  let take-item-list-subset rpos item-list =
    let-rec iter acc lst =
      match lst with
      | [] -> (List.reverse acc, [])
      | item :: rest ->
          let (_, epos, _, _) = item in
          if epos <= rpos then iter (item :: acc) rest
          else (List.reverse acc, lst)
    in
    iter [] item-list

  let set-text-color-opt color-opt ctx =
    match color-opt with
    | None -> ctx
    | Some color -> ctx |> set-text-color color

  let read-inline-substr ctx src lpos rpos =
    if lpos == rpos then inline-nil
    else
      let substr = string-sub src lpos (rpos - lpos) in
      read-inline ctx (embed-string substr)

  let build-colored-ib ctx src item-list =
    let-rec iter ctx acc lpos rpos item-list =
      match item-list with
      | [] ->
          let ib-rest = read-inline-substr ctx src lpos rpos in
          acc ++ ib-rest
      | (bpos, epos, _, color-opt) :: rest ->
          let ib-left = read-inline-substr ctx src lpos bpos in
          let (subset, rest1) = take-item-list-subset epos rest in
          let ctx1 = ctx |> set-text-color-opt color-opt in
          let ib-mid = iter ctx1 inline-nil bpos epos subset in
          iter ctx (acc ++ ib-left ++ ib-mid) epos rpos rest1
    in
    iter ctx inline-nil 0 (string-length src) item-list

  % for debugging
  let print-item-list ctx item-list =
    let-rec iter acc lst =
      match lst with
      | [] -> acc
      | (bpos, epos, s, _) :: rest ->
          let msg = `[` ^ s ^ `:` ^ arabic bpos ^ `-` ^ arabic epos ^ `]` in
          let ib = read-inline ctx (embed-string msg) in
          iter (acc ++ ib) rest
    in
    iter inline-nil item-list

  let scan ctx rule code =
    let p = many rule |> map List.concat in
    match parse exec-ctx-init p code with
    | None ->
        read-inline ctx (embed-string code)
    | Some (item-list, st) ->
        let ib =
          serialize-item-list item-list
            |> build-colored-ib ctx st#src
            % |> print-item-list ctx
        in
        let ib-rest =
          let len = string-length st#src in
          let rest = string-sub st#src st#offset (len - st#offset) in
          read-inline ctx (embed-string rest)
        in
        ib ++ ib-rest

end
