@import: token
@import: parser
@import: regex


module Language : sig

  type item
  type rule

  val pattern : string -> rule
  val patterns : rule list -> rule
  val capture : int -> (item -> item) -> rule -> rule
  val token : token -> item -> item
  val scan : context -> rule -> string -> inline-boxes

end = struct

  type item =
    | Matched of int * int * string * color option
    | NotMatched

  type rule = (item list) exec-ctx parser

  let pattern pat =
    let p = Regex.compile pat in
    p >>= (fun matched -> (
      let item-list = matched |> List.map (fun data -> (
        match data with
        | None -> NotMatched
        | Some (bpos, epos, s) -> Matched (bpos, epos, s, None)
      )) in
      return item-list
    ))

  let patterns = choice

  let list-nth-map n f lst =
    let-rec iter k lst =
      match lst with
      | [] -> []
      | x :: xs ->
          if k == n then (f x) :: xs
          else x :: iter (k + 1) xs
    in
    iter 0 lst

  let capture n f t =
    t >>= (fun item-list -> (
      return (list-nth-map n f item-list)
    ))

  let token tok item =
    match item with
    | NotMatched -> NotMatched
    | Matched (bpos, epos, s, _) ->
        Matched (bpos, epos, s, Some (ColorScheme.color-of tok))

  let take-item-list-subset rpos item-list =
    let-rec iter acc lst =
      match lst with
      | [] -> (List.reverse acc, [])
      | item :: rest -> (
          match item with
          | NotMatched -> iter acc rest
          | Matched (_, epos, _, _) ->
              if epos <= rpos then iter (item :: acc) rest
              else (List.reverse acc, lst)
        )
    in
    iter [] item-list

  let set-text-color-opt color-opt ctx =
    match color-opt with
    | None -> ctx
    | Some color -> ctx |> set-text-color color

  let read-inline-substr ctx src lpos rpos =
    if lpos == rpos then inline-nil
    else
      let substr = string-sub src lpos (rpos - lpos) in
      read-inline ctx (embed-string substr)

  let build-colored-ib ctx src item-list =
    let-rec iter ctx acc lpos rpos item-list =
      match item-list with
      | [] ->
          let ib-rest = read-inline-substr ctx src lpos rpos in
          acc ++ ib-rest
      | (NotMatched) :: rest -> iter ctx acc lpos rpos rest
      | (Matched (bpos, epos, _, color-opt)) :: rest ->
          let ib-left = read-inline-substr ctx src lpos bpos in
          let (subset, rest1) = take-item-list-subset epos rest in
          let ctx1 = ctx |> set-text-color-opt color-opt in
          let ib-mid = iter ctx1 inline-nil bpos epos subset in
          iter ctx (acc ++ ib-left ++ ib-mid) epos rpos rest1
    in
    iter ctx inline-nil 0 (string-length src) item-list

  % for debugging
  let print-item-list ctx item-list =
    let-rec iter acc lst =
      match lst with
      | [] -> acc
      | (NotMatched) :: rest -> iter acc rest
      | (Matched (bpos, epos, s, _)) :: rest ->
          let msg = `[` ^ s ^ `:` ^ arabic bpos ^ `-` ^ arabic epos ^ `]` in
          let ib = read-inline ctx (embed-string msg) in
          iter (acc ++ ib) rest
    in
    iter inline-nil item-list

  let scan ctx rule code =
    let p = many rule |> map List.concat in
    match parse exec-ctx-init p code with
    | None ->
        read-inline ctx (embed-string code)
    | Some (item-list, st) ->
        let ib = build-colored-ib ctx st#src item-list in
        % let ib = print-item-list ctx item-list in
        let ib-rest =
          let len = string-length st#src in
          let rest = string-sub st#src st#offset (len - st#offset) in
          read-inline ctx (embed-string rest)
        in
        ib ++ ib-rest

end
