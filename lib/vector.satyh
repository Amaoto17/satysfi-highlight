module Vec : sig

  type 'a t

  val create : unit -> 'a t
  val size : 'a t -> int
  val get : 'a t -> int -> 'a option
  val push : 'a t -> 'a -> unit
  val set : 'a t -> int -> 'a -> unit

end = struct

  type 'a heap =
    | Empty
    | Node of (|
        data  : 'a ref;
        left  : ('a heap) ref;
        right : ('a heap) ref;
      |)

  type 'a t = (|
    heap : ('a heap) ref;
    size : int ref;
  |)

  type dir = L | R

  let ref e = let-mutable x <- e in x

  let create () = (|
    heap = ref Empty;
    size = ref 0;
  |)

  let size t = !t#size

  let singleton data = Node (|
    data  = ref data;
    left  = ref Empty;
    right = ref Empty;
  |)

  let path n =
    let-rec iter acc k =
      if k < 2 then acc
      else if k mod 2 == 0 then iter (L :: acc) (k / 2)
      else iter (R :: acc) (k / 2)
    in
    iter [] (n + 1)

  let get t n =
    let-rec iter heap path =
      match !heap with
      | Empty -> None
      | Node v -> (
          match path with
          | [] -> Some (!(v#data))
          | (L) :: rest -> iter v#left  rest
          | (R) :: rest -> iter v#right rest
        )
    in
    iter t#heap (path n)

  let push t data =
    let-rec iter heap path =
      match !heap with
      | Empty -> heap <- singleton data
      | Node v -> (
          match path with
          | [] -> abort-with-message `Vec.push`
          | (L) :: rest -> iter v#left  rest
          | (R) :: rest -> iter v#right rest
        )
    in
    let () = iter t#heap (path (size t)) in
    let s = t#size in s <- !s + 1

  let set t n data =
    let-rec iter heap path =
      match !heap with
      | Empty -> abort-with-message `index out of range`
      | Node v -> (
          match path with
          | [] -> let d = v#data in d <- data
          | (L) :: rest -> iter v#left  rest
          | (R) :: rest -> iter v#right rest
        )
    in
    iter t#heap (path n)

end
